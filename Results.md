# Ergebnisse der Analyse:

Die erste Implementierung habe ich mit Hilfe von ChatGPT in Python umgesetzt. Zuerst findet die schnelle Fourieranalyse statt. Im nächsten Schritt werden die Ergebnisse geplottet, einmal als Spektogramm. Dabei wird die Zeit auf der x-Achse und die Frequenz auf der y-Achse dargestellt. Die Farbe zeigt die Magnitude an. Die Fourieranalyse wurde einmal mit einer Blockgröße von 512 und einmal mit einer Blockgröße von 256 ausgeführt, jeweils mit einem Shift von 1. Bei einer Blockgröße von 1024 wurde die Analyse zwar noch durchgeführt, aber das Plotten des Ergebnisses hat nicht mehr funktioniert.

Für die anderen Teile der Aufgabe habe ich den Speicherverbrauch gemessen, einmal in Python, einmal in Java und dann nochmal in Python, aber auf der WSL, also einem anderen Betriebssystem.

Mit `tracemalog` habe ich den Speicherbedarf der Analyse in Python verfolgt, indem ich die Messung des Speicherplatzes vor der Schleife, die die Analyse ausführt, starte und nach der Schleife wieder schließe. Für Windows habe ich den Speicherverbrauch auch graphisch dargestellt, auf Linux war das ohne Weiteres nicht machbar, weswegen ich den Speicherverbrauch in der Konsole ausgegeben habe. In Java habe ich den Speicherverbrauch mit `memoryusage.used` verfolgt, was den Speicherverbrauch der JVM zu einem bestimmten Zeitpunkt anzeigt. Die Werte habe ich gespeichert und geplottet.

Zwischen den Betriebssystemen gab es einen Unterschied beim Umgang mit einem zu hohen Verbrauch des Arbeitspeichers. Beim Ausführen in Windows hat sich das Programm bei einem zu hohen Speicherverbrauch aufgehängt, soweit, dass sogar mein ganzer Laptop langsamer wurde. Außerdem ist aufgefallen, dass der Speicherbedarf bei jeder Ausführung identisch ist (bei gleichem OS). Zwischen Linux und Windows gibt es einen Unterschied von 2MB. In Linux wurde der Prozess gekillt, wenn der Speicherverbrauch zu groß wurde. Zwischen Python und Java gab es einen Unterschied in der Speicherverwaltung selbst. In Python ist der Verbrauch sehr linear gestiegen, während in Java in regelmäßigen Abständen Speicher freigegeben wurde, sodass der Höchstverbrauch sich in Grenzen gehalten hat. Ich vermute, dass der Garbage Collector dafür verantwortlich war. Außerdem musste ich in Java den Speicherplatz der JVM vergrößern, um mein Programm ausführen zu können.
